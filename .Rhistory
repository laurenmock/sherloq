mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val))
}
c(rep(1, 20), rep(2, 20))
c(rep(1, 30), rep(2, 30), rep(3, 30), rep(4, 30))
length(c(rep(1, 30), rep(2, 30), rep(3, 30), rep(4, 30)))
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE){
# percentile
pct <- 1 - alpha
#match.arg(arg = "parametric", choices = c(TRUE, FALSE))
# confirm that all col_sample and col_value exist
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# if col_lot exists, find # of unique values (number of reagent lots), otherwise set to 1
if(col_lot %in% names(df)){
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}else{
df$lot <- 1
n_lots <- 1
}
# if separate_lots = TRUE --> keep this val no matter what (but include warning for n_lots = 4+)
# if separate_lots = FALSE --> anything 4+ should be changed to 1
# for now, imagine that I want to look at all lots separately no matter what!!!
# loop through each reagent lot (if n_lots = 1, then we will only go through the loop once)
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val))
}
}
LoB(df, "reagent_lot", "sample", "pg.ml")
df$reagent_lot <- c(rep(1, 30), rep(2, 30), rep(3, 30), rep(4, 30))
LoB(df, "reagent_lot", "sample", "pg.ml")
document()
rm(LoB)
document()
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
# percentile
pct <- 1 - alpha
#match.arg(arg = "parametric", choices = c(TRUE, FALSE))
# confirm that all col_sample and col_value exist
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# if col_lot exists, find # of unique values (number of reagent lots), otherwise set to 1
if(col_lot %in% names(df)){
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}else{
df$lot <- 1
n_lots <- 1
}
# combine lots if >3 and user has not specified always_sep_lots
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("CLSI guidelines recommend you don't separate...")
}
# if separate_lots = TRUE --> keep this val no matter what (but include warning for n_lots = 4+)
# if separate_lots = FALSE --> anything 4+ should be changed to 1
# loop through each reagent lot (if n_lots = 1, then we will only go through the loop once)
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val))
}
}
LoB(df, "reagent_lot", "sample", "pg.ml")
View(df)
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
# percentile
pct <- 1 - alpha
#match.arg(arg = "parametric", choices = c(TRUE, FALSE))
# confirm that all col_sample and col_value exist
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# if col_lot exists, find # of unique values (number of reagent lots), otherwise set to 1
if(col_lot %in% names(df)){
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}else{
df$lot <- 1
n_lots <- 1
}
# combine lots if >3 and user has not specified always_sep_lots
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("CLSI guidelines recommend you don't separate...")
}
# if separate_lots = TRUE --> keep this val no matter what (but include warning for n_lots = 4+)
# if separate_lots = FALSE --> anything 4+ should be changed to 1
# loop through each reagent lot (if n_lots = 1, then we will only go through the loop once)
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val))
}
}
View(df)
# percentile
pct <- 1 - alpha
# if col_lot exists, find # of unique values (number of reagent lots), otherwise set to 1
if(col_lot %in% names(df)){
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}else{
df$lot <- 1
n_lots <- 1
}
always_sep_lots <- FALSE
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
# This took like 20 minutes to type out
blank_df <- data.frame(reagent_lot = c(rep(1, 12*5), rep(2, 12*5)),
day = rep(rep(c(1, 2, 3), each = 4, times = 10)),
sample = rep(c(1, 2, 3, 4, 5), each = 12, times = 2),
replicate = rep(c(1, 2, 3, 4), times = 3*5*2),
`pg/ml` = c(2.6, -.8, 5.5, 6.0,
4.5, .6, -2.3, 3.4,
5.9, 7.6, 4.1, -1.4,
1.0, 2.9, 4.9, 8.0,
6.9, 5.0, 3.4, 1.2,
6.5, 5.6, -2.2, 2.3,
-4.4, -3.4, 7.0, 6.9,
4.3, 3.2, -1.4, 4.2,
5.9, 7.6, 3.8, 5.8,
1.5, -1.9, 5.1, 5.7,
4.1, 4.5, -.6, .5,
5.4, 7.6, 4.4, 6.6,
1.2, -.7, 6.1, 5.1,
4.8, 3.3, -2.8, -1.4,
8.7, 3.6, 5.1, 3.5,
4.6, 4.1, 1.6, 3.7,
2.2, .7, 4.6, 2.6,
1.1, -4.4, .9, .7,
9.2, 8.3, 4.8, 5.4,
4.8, 6.3, 5.4, 9.6,
7.7, 3.1, 6.1, 10.0,
6.1, 3.2, 3.9, 1.4,
3.1, 4.1, 1.0, 3.4,
.1, .4, 2.9, -1.6,
4.0, 11.5, 4.5, 3.6,
4.4, 6.8, 7.1, 4.2,
3.7, 3.7, 5.3, 4.5,
4.0, 6.2, -.2, 2.3,
1.6, 2.6, 6.4, 5.7,
4.2, 3.7, 1.4, 1.5))
# Lauren!!
df <- blank_df |> subset(reagent_lot == 1)
LoB(df, "reagent_lot", "sample", "pg.ml")
View(df)
LoB(blank_df, "reagent_lot", "sample", "pg.ml")
test <- df
test <- blank_df
test$reagent_lot <- c(rep(1, 30), rep(2, 30), rep(3, 30), rep(4, 30))
LoB(test, "reagent_lot", "sample", "pg.ml")
LoB(test, "reagent_lot", "sample", "pg.ml", always_sep_lots = TRUE)
LoB(test, "reagent_lot", "sample", "pg.ml", always_sep_lots = TRUE)
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
# percentile
pct <- 1 - alpha
#match.arg(arg = "parametric", choices = c(TRUE, FALSE))
# confirm that all col_sample and col_value exist
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# if col_lot exists, find # of unique values (number of reagent lots), otherwise set to 1
if(col_lot %in% names(df)){
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}else{
df$lot <- 1
n_lots <- 1
}
# combine lots if >3 and user has not specified always_sep_lots
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided,
CLSI guidelines recommend combining all reagent lots.
Consider setting `always_sep_lots` = FALSE.")
}
# if separate_lots = TRUE --> keep this val no matter what (but include warning for n_lots = 4+)
# if separate_lots = FALSE --> anything 4+ should be changed to 1
# loop through each reagent lot (if n_lots = 1, then we will only go through the loop once)
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed.
Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val))
}
}
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
# percentile
pct <- 1 - alpha
#match.arg(arg = "parametric", choices = c(TRUE, FALSE))
# confirm that all col_sample and col_value exist
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# if col_lot exists, find # of unique values (number of reagent lots), otherwise set to 1
if(col_lot %in% names(df)){
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}else{
df$lot <- 1
n_lots <- 1
}
# combine lots if >3 and user has not specified always_sep_lots
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided,
CLSI guidelines recommend combining all reagent lots.
Consider setting `always_sep_lots` = FALSE.")
}
# loop through each reagent lot (if n_lots = 1, then we will only go through the loop once)
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed.
Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val))
}
}
LoB(test, "reagent_lot", "sample", "pg.ml", always_sep_lots = TRUE)
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
# percentile
pct <- 1 - alpha
#match.arg(arg = "parametric", choices = c(TRUE, FALSE))
# confirm that all col_sample and col_value exist
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# if col_lot exists, find # of unique values (number of reagent lots), otherwise set to 1
if(col_lot %in% names(df)){
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}else{
df$lot <- 1
n_lots <- 1
}
# combine lots if >3 and user has not specified always_sep_lots
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided, CLSI guidelines recommend combining all reagent lots. Consider setting `always_sep_lots` = FALSE.")
}
# loop through each reagent lot (if n_lots = 1, then we will only go through the loop once)
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val))
}
}
LoB(test, "reagent_lot", "sample", "pg.ml", always_sep_lots = TRUE)
LoB(test, "reagent_lot", "sample", "pg.ml", always_sep_lots = TRUE, parametric = TRUE)
LoB(test, "reagent_lot", "sample", "pg.ml", parametric = TRUE)
shapiro.test(lot_l[[col_value]])$p.value <= 0.05
LoB(df, "reagent_lot", "sample", "pg.ml", parametric = TRUE)
# This took like 20 minutes to type out
blank_df <- data.frame(reagent_lot = c(rep(1, 12*5), rep(2, 12*5)),
day = rep(rep(c(1, 2, 3), each = 4, times = 10)),
sample = rep(c(1, 2, 3, 4, 5), each = 12, times = 2),
replicate = rep(c(1, 2, 3, 4), times = 3*5*2),
`pg/ml` = c(2.6, -.8, 5.5, 6.0,
4.5, .6, -2.3, 3.4,
5.9, 7.6, 4.1, -1.4,
1.0, 2.9, 4.9, 8.0,
6.9, 5.0, 3.4, 1.2,
6.5, 5.6, -2.2, 2.3,
-4.4, -3.4, 7.0, 6.9,
4.3, 3.2, -1.4, 4.2,
5.9, 7.6, 3.8, 5.8,
1.5, -1.9, 5.1, 5.7,
4.1, 4.5, -.6, .5,
5.4, 7.6, 4.4, 6.6,
1.2, -.7, 6.1, 5.1,
4.8, 3.3, -2.8, -1.4,
8.7, 3.6, 5.1, 3.5,
4.6, 4.1, 1.6, 3.7,
2.2, .7, 4.6, 2.6,
1.1, -4.4, .9, .7,
9.2, 8.3, 4.8, 5.4,
4.8, 6.3, 5.4, 9.6,
7.7, 3.1, 6.1, 10.0,
6.1, 3.2, 3.9, 1.4,
3.1, 4.1, 1.0, 3.4,
.1, .4, 2.9, -1.6,
4.0, 11.5, 4.5, 3.6,
4.4, 6.8, 7.1, 4.2,
3.7, 3.7, 5.3, 4.5,
4.0, 6.2, -.2, 2.3,
1.6, 2.6, 6.4, 5.7,
4.2, 3.7, 1.4, 1.5))
document()
check()
document()
check()
install()
library(detection)
LoB(blank_df)
LoB(blank_df, parametric = FALSE)
install()
