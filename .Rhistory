4.0, 6.2, -.2, 2.3,
1.6, 2.6, 6.4, 5.7,
4.2, 3.7, 1.4, 1.5))
# Lauren!!
df <- blank_df |> filter(reagent_lot == 1)
# Lauren!!
df <- blank_df |> subset(reagent_lot == 1)
LoB(df)
LoB(df, parametric = TRUE)
?nrow
?unique
?do.call
?aggregate
?with
document()
check()
check()
check()
check()
check()
document()
check()
B = pct = NULL
document()
document()
document()
document()
check()
LoB <- function(df, alpha=0.05, parametric = FALSE){
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(df$pg.ml)
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(df$pg.ml)$p.value <= 0.05){
message("These measurements do not appear to be normally distributed. Consider performing a log transformation or use the non-parametric approach.")
}
# mean and SD
mean_B <- mean(df$pg.ml)
sd_B <- stats::sd(df$pg.ml)
# critical value
K <- unique(df$sample) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB(df)
LoB(df, parametric = TRUE)
rm(LoB)
install()
LoB(df)
library(devtools)
# This took like 20 minutes to type out
blank_df <- data.frame(reagent_lot = c(rep(1, 12*5), rep(2, 12*5)),
day = rep(rep(c(1, 2, 3), each = 4, times = 10)),
sample = rep(c(1, 2, 3, 4, 5), each = 12, times = 2),
replicate = rep(c(1, 2, 3, 4), times = 3*5*2),
`pg/ml` = c(2.6, -.8, 5.5, 6.0,
4.5, .6, -2.3, 3.4,
5.9, 7.6, 4.1, -1.4,
1.0, 2.9, 4.9, 8.0,
6.9, 5.0, 3.4, 1.2,
6.5, 5.6, -2.2, 2.3,
-4.4, -3.4, 7.0, 6.9,
4.3, 3.2, -1.4, 4.2,
5.9, 7.6, 3.8, 5.8,
1.5, -1.9, 5.1, 5.7,
4.1, 4.5, -.6, .5,
5.4, 7.6, 4.4, 6.6,
1.2, -.7, 6.1, 5.1,
4.8, 3.3, -2.8, -1.4,
8.7, 3.6, 5.1, 3.5,
4.6, 4.1, 1.6, 3.7,
2.2, .7, 4.6, 2.6,
1.1, -4.4, .9, .7,
9.2, 8.3, 4.8, 5.4,
4.8, 6.3, 5.4, 9.6,
7.7, 3.1, 6.1, 10.0,
6.1, 3.2, 3.9, 1.4,
3.1, 4.1, 1.0, 3.4,
.1, .4, 2.9, -1.6,
4.0, 11.5, 4.5, 3.6,
4.4, 6.8, 7.1, 4.2,
3.7, 3.7, 5.3, 4.5,
4.0, 6.2, -.2, 2.3,
1.6, 2.6, 6.4, 5.7,
4.2, 3.7, 1.4, 1.5))
# Lauren!!
df <- blank_df |> subset(reagent_lot == 1)
check()
install()
LoB(df)
LoB(df, parametric = TRUE)
detach("package:detection", unload=TRUE)
install()
LoB(df)
library(detection)
LoB(df)
LoB(df, parametric = TRUE)
detach("package:detection", unload=TRUE)
install()
library(detection)
LoB(df, parametric = TRUE)
?floor
detach("package:detection", unload=TRUE)
library(detection)
install()
library(detection)
LoB(df)
View(df)
LoB(df, "sample", "pg.ml")
LoB(df, col_sample = "sample", col_values = "pg.ml")
LoB <- function(df, col_sample, col_values, alpha=0.05, parametric = FALSE){
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(df$col_values)
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(df$col_values)$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(df$col_values)
sd_B <- stats::sd(df$col_values)
# critical value
K <- unique(df$col_sample) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB(df, col_sample = "sample", col_values = "pg.ml")
LoB <- function(df, column){df$column}
LoB(df)
LoB(df, "sample")
LoB(df, sample)
LoB <- function(df, col_sample, col_values, alpha=0.05, parametric = FALSE){
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(df$col_values)
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(df$col_values)$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(df$col_values)
sd_B <- stats::sd(df$col_values)
# critical value
K <- unique(df$col_sample) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB <- function(df, col_sample, col_values, alpha=0.05, parametric = FALSE){
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
# sorted <- sort(df$col_values)
sorted <- sort(df["col_values"])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(df$col_values)$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
# mean_B <- mean(df$col_values)
# sd_B <- stats::sd(df$col_values)
mean_B <- mean(df["col_values"])
sd_B <- stats::sd(df["col_values"])
# critical value
#K <- unique(df$col_sample) |> length()
K <- unique(df["col_sample"]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB(df, "sample", "pg.ml")
LoB <- function(df, col_sample, col_values, alpha=0.05, parametric = FALSE){
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
# sorted <- sort(df$col_values)
sorted <- sort(df[col_values])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
# if(shapiro.test(df$col_values)$p.value <= 0.05){
#   message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
# }
if(shapiro.test(df[col_values])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
# mean_B <- mean(df$col_values)
# sd_B <- stats::sd(df$col_values)
mean_B <- mean(df[col_values])
sd_B <- stats::sd(df[col_values])
# critical value
#K <- unique(df$col_sample) |> length()
K <- unique(df[col_sample]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB(df, "sample", "pg.ml")
test <- function(dat, col){
df$col |> mean()
}
test(df, pg.ml)
mean(df$pg.ml)
test <- function(dat, col){
df$col
}
test(df, pg.ml)
test <- function(dat, col){
df$col |> mean()
}
test(df, "pg.ml")
test <- function(dat, col){
df[col] |> mean()
}
test(df, "pg.ml")
LoB + cp*sd_l_lot2
test <- function(dat, col){
df[,col] |> mean()
}
test(df, "pg.ml")
LoB <- function(df, col_sample, col_values, alpha=0.05, parametric = FALSE){
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
# sorted <- sort(df$col_values)
sorted <- sort(df[,col_values])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
# if(shapiro.test(df$col_values)$p.value <= 0.05){
#   message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
# }
if(shapiro.test(df[,col_values])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
# mean_B <- mean(df$col_values)
# sd_B <- stats::sd(df$col_values)
mean_B <- mean(df[,col_values])
sd_B <- stats::sd(df[,col_values])
# critical value
#K <- unique(df$col_sample) |> length()
K <- unique(df[,col_sample]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB(df, "sample", "pg.ml")
LoB(df, "sample", "pg.ml", parametric = TRUE)
LoB(df, "sample", "pg.ml", parametric = "TRUE"hi)
LoB(df, "sample", "pg.ml", parametric = "hi")
LoB <- function(df, col_lot, col_sample, col_values,
alpha=0.05, parametric = FALSE){
match.arg(arg = "parametric", choices = c(TRUE, FALSE))
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(df[,col_values])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(df[,col_values])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(df[,col_values])
sd_B <- stats::sd(df[,col_values])
# critical value
K <- unique(df[,col_sample]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB(df, "sample", "pg.ml", parametric = "hi")
LoB <- function(df, col_lot, col_sample, col_values,
alpha=0.05, parametric = c(FALSE, TRUE)){
#match.arg(arg = "parametric", choices = c(TRUE, FALSE))
parametric <- match.arg(parametric)
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(df[,col_values])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(df[,col_values])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(df[,col_values])
sd_B <- stats::sd(df[,col_values])
# critical value
K <- unique(df[,col_sample]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB(df, "sample", "pg.ml", parametric = "hi")
LoB(df, "sample", "pg.ml", parametric = TRUE)
LoB <- function(df, col_lot, col_sample, col_values,
alpha=0.05, parametric = FALSE){
match.arg(arg = "parametric", choices = c(TRUE, FALSE))
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(df[,col_values])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(df[,col_values])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(df[,col_values])
sd_B <- stats::sd(df[,col_values])
# critical value
K <- unique(df[,col_sample]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB(df, "sample", "pg.ml", parametric = TRUE)
LoB(df, "sample", "pg.ml", parametric = "TRUE")
LoB <- function(df, col_lot, col_sample, col_values,
alpha=0.05, parametric = FALSE){
#match.arg(arg = "parametric", choices = c(TRUE, FALSE))
# percentile
pct <- 1 - alpha
# number of reagents
B <- nrow(df)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(df[,col_values])
# interpolate measurement for exact rank position (LoB)
LoB_val <-
sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(shapiro.test(df[,col_values])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(df[,col_values])
sd_B <- stats::sd(df[,col_values])
# critical value
K <- unique(df[,col_sample]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val <- mean_B + cp*sd_B
}
return(LoB_val)
}
LoB(df, "sample", "pg.ml", parametric = "TRUE")
LoB(df, "sample", "pg.ml", parametric = TRUE)
install("detection")
install(detection)
install()
rm(LoB)
install()
library(detection)
LoB(df, "sample", "pg.ml", parametric = TRUE)
rm(test)
install()
library(detection)
LoB(df, "sample", "pg.ml", parametric = TRUE)
