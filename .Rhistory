test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
#---
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE), data = x))
test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
# quadratic
quad_mod <- lapply(lots_list, function(x)
lm(x[[col_sd]] ~ poly(x[[col_avg]], degree = 2, raw = TRUE)))
# quadratic
quad_mod <- lapply(lots_list, function(x)
lm(x[[col_sd]] ~ poly(x[[col_avg]], degree = 2, raw = TRUE)))
test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
quad_mod <- lapply(lots_list, function(x)
lm(col_sd ~ poly(col_avg, degree = 2, raw = TRUE)))
expression(col_sd)
eval(col_sd
)
noquote(col_sd)
quad_mod <- lapply(lots_list, function(x)
lm(noquote(col_sd) ~ poly(noquote(col_avg), degree = 2, raw = TRUE)))
noquote(col_sd)
noquote(col_avg)
#---
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE), data = x))
quad_mod <- lapply(lots_list, function(x)
lm(noquote(col_sd) ~ poly(noquote(col_avg), degree = 2, raw = TRUE), data = x))
noquote(col_sd)
quad_mod <- lapply(lots_list, function(x)
lm(noquote(col_sd) ~ poly(avg, degree = 2, raw = TRUE), data = x))
noquote(col_sd)
class(noquote(col_sd))
expression(col_sd)
quad_mod <- lapply(lots_list, function(x)
lm(expression(col_sd) ~ poly(expression(col_avg), degree = 2, raw = TRUE), data = x))
quad_mod <- lapply(lots_list, function(x)
lm(as.formula(col_sd) ~ poly((col_avg), degree = 2, raw = TRUE), data = x))
quad_mod <- lapply(lots_list, function(x)
lm(reformulate(col_sd) ~ poly((col_avg), degree = 2, raw = TRUE), data = x))
reformulate(col_sd)
quad_mod <- lapply(lots_list, function(x)
lm(col_sd ~ poly(col_avg, degree = 2, raw = TRUE),
data = list(col_sd = x[[col_sd]],
col_avg = x[col_avg])))
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE),
data = x)
#---
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE), data = x))
test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
#---
#---
# quad_mod <- lapply(lots_list, function(x)
#   lm(sd_wl ~ avg + I(avg^2), data = x))
# test_mod <- quad_mod[[1]]
# newdat <- as.data.frame(x_vals) |> setNames("avg")
# predict(test_mod, newdat)
#---
# Sadler
# sadler_mod <- lapply(lots_list, function(x)
#   nls(sd_wl ~ I((a + b*avg)), start = list(a = 0, b = 1), data = sample_df))
sadler_mod <- lin_mod
# fix this later!
all_mods <- list(lin_mod, quad_mod, sadler_mod) |> setNames(mod_names)
# find model with lowest AIC for each reagent lot
min_AIC <- vector()
for(l in 1:n_lots){
min_AIC[l] <- c(lapply(lin_mod, AIC)[[l]],
lapply(quad_mod, AIC)[[l]],
lapply(sadler_mod, AIC)[[l]]) |> which.min()
}
# which model is necessary? (most complex of all reagent lots)
mod_nb <- max(min_AIC)
best_mod <- mod_names[mod_nb]
# if user has selected a model
if(model != "lowest AIC"){
final_mod <- model
# warning if this model does not have the lowest AIC
if(best_mod != final_mod){
message(paste0("Warning: ", best_mod, " has a lower AIC than the selected model."))
}
# if user wants model with lowest AIC
}else{
final_mod <- best_mod
}
#----- plot precision profiles -----#
# set x and y limits for plot
x_lims <- c(min(sample_df[[col_avg]] - 0.1), max(sample_df[[col_avg]]) + 0.1)
y_lims <- c(min(sample_df[[col_sd]] - 0.1), max(sample_df[[col_sd]]) + 0.1)
# set functions for plotting each precision model type
funs <- list(c(1, x), c(1, x, x^2), c(1))
# plot profile for first reagent lot
lot_1 <- df[df[[col_lot]] == 1,]
plot(lot_1[[col_avg]], lot_1[[col_sd]],
xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
x_vals <- seq(from = x_lims[1], to = x_lims[2], length = 50)
lines(x_vals, sapply(x_vals, function(x) c(1, x, x^2) %*% all_mods[[final_mod]][[1]]$coeff),
col = 2, lty = 2)
# use predict instead of this
# plot remaining profiles (if any)
if(n_lots > 1){
# loop through remaining reagent lots
for(l in 2:n_lots){
lot_l <- df[df[[col_lot]] == l,]
points(lot_l[[col_avg]], lot_l[[col_sd]], col = l+1, pch = 16)
# and precision model
lines(x_vals, sapply(x_vals, function(x) c(1, x, x**2) %*% all_mods[[final_mod]][[l]]$coeff),
col = l+1, lty = 2)
}
}
#----- calculate LoD -----#
# # loop through each reagent lot
# LoD_vals <- list()
# for(l in 1:n_lots){
#
#   # look at each lot separately
#   lot_l <- df[df[[col_lot]] == l,]
#
#   # critical value
#   N_tot <- nrow(lot_l)
#   K <- unique(lot_l[[col_sample]]) |> length() # number of samples
#   cp <- qnorm(pct) / (1 - (1/(4*(N_tot-K)) ))
#
#   # select model with lower AIC
#   if(AIC1 <= AIC2){
#     init_LoD_vals[l] <- LoB + cp*(c(1, .51) %*% summary(pp_model1)$coef[,1])
#   }else{
#     init_LoD_vals[l] <- LoB + cp*(c(1, .51, .51^2) %*% summary(pp_model2)$coef[,1])
#   }
# }
# look at all lots together
# return(LoD_vals)
}
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE),
data = x)
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE),
data = list(col_sd = x[[col_sd]],
col_avg = x[col_avg])))
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE),
data = list(sd_wl = x[[col_sd]],
avg = x[col_avg])))
quad_mod <- lapply(lots_list, function(x)
lm(col_sd ~ poly(col_avg, degree = 2, raw = TRUE),
data = list(col_sd = x[[col_sd]],
col_avg = x[[col_avg]])))
quad_mod <- lapply(lots_list, function(x)
lm(col_sd ~ poly(col_avg, degree = 2, raw = TRUE),
data = list(col_sd = x[[col_sd]],
col_avg = x[[col_avg]])))
View(quad_mod)
quad_mod <- lapply(lots_list, function(x)
lm(col_sd ~ poly(col_avg, degree = 2, raw = TRUE),
data = list(col_sd = x[[col_sd]], col_avg = x[[col_avg]])))
test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
quad_mod <- lapply(lots_list, function(x)
lm(col_sd ~ poly(col_avg, degree = 2, raw = TRUE),
data = list(col_sd = x[[col_sd]], col_avg = x[[col_avg]])))
test_mod <- quad_mod[[1]]
summary(test_mod)
#---
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE), data = x))
test_mod <- quad_mod[[1]]
summary(test_mod)
#---
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE), data = x))
test_mod <- quad_mod[[1]]
summary(test_mod)
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
quad_mod <- lapply(lots_list, function(x)
lm(col_sd ~ poly(col_avg, degree = 2, raw = TRUE),
data = list(col_sd = x[[col_sd]], col_avg = x[[col_avg]])))
test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
newdat <- as.data.frame(x_vals) |> setNames("poly(avg, degree = 2, raw = TRUE)1")
predict(test_mod, newdat)
#---
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE), data = x))
test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
quad_mod <- lapply(lots_list, function(x)
lm(col_sd ~ poly(col_avg, degree = 2, raw = TRUE),
data = list(col_sd = x[[col_sd]], col_avg = x[[col_avg]])))
test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE),
data = x))
test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
names(df) == col_sd
names(df)[names(df) == col_sd]
# rename columns in df
names(df)[names(df) == col_sd] <- "sd_wl"
View(df)
# rename columns in df
names(df)[names(df) == col_sd] <- "a"
View(df)
names(df)[names(df) == col_avg] <- "avg"
# rename columns in df
names(df)[names(df) == col_sd] <- "sd_wl"
names(df)[names(df) == col_avg] <- "avg"
View(df)
# rename columns in df
names(df)[names(df) == col_sd] <- "sd_wl"
names(df)[names(df) == col_avg] <- "avg"
sample_df <- data.frame(reagent_lot = c(rep("1", 6), rep("2", 6)),
sample = rep(LETTERS[1:6], 2),
avg = c(.69, 1.42, 2.65, 4.08, 6.08, 10.36,
.78, 1.73, 2.89, 3.82, 6.33, 10.92),
sd_wl = c(.39, .39, .46, .55, .64, 1.12,
.29, .54, .55, .63, .82, 1.38))
# rename columns in df
names(df)[names(df) == col_sd] <- "sd_wl"
names(df)[names(df) == col_avg] <- "avg"
View(df)
df <- sample_df
# rename columns in df
names(df)[names(df) == col_sd] <- "sd_wl"
names(df)[names(df) == col_avg] <- "avg"
View(df)
#---
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ poly(avg, degree = 2, raw = TRUE), data = x))
test_mod <- quad_mod[[1]]
newdat <- as.data.frame(x_vals) |> setNames("avg")
predict(test_mod, newdat)
quad_mod <- lapply(lots_list, function(x)
lm(sd_wl ~ avg + I(avg^2), data = x))
plot(lot_1[[col_avg]], lot_1[[col_sd]],
xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 50) |>
as.data.frame() |> setNames("avg")
lines(new_vals, predict(test_mod, newdat))
y <- predict(test_mod, newdat)
lines(new_vals, predict(test_mod, newdat) |> as.data.frame())
predict(test_mod, newdat)
predict(test_mod, newdat) |> as.data.frame()
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 50) |>
as.data.frame() |> setNames("avg")
new_preds <- predict(test_mod, newdat)
new_preds <- predict(test_mod, new_vals)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 50)
new_preds <- predict(test_mod, new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds)
lines(new_vals, new_preds, col = 2, lty = 2)
plot(lot_1[[col_avg]], lot_1[[col_sd]],
xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 30)
new_preds <- predict(test_mod, new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
new_preds <- predict(all_mods[[final_mod]][[1]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
plot(lot_1[[col_avg]], lot_1[[col_sd]],
xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 30)
new_preds <- predict(all_mods[[final_mod]][[1]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
plot(lot_1[[col_avg]], lot_1[[col_sd]],
xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 30)
new_preds <- predict(all_mods[[final_mod]][[1]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
# plot remaining profiles (if any)
if(n_lots > 1){
# loop through remaining reagent lots
for(l in 2:n_lots){
lot_l <- df[df[[col_lot]] == l,]
points(lot_l[[col_avg]], lot_l[[col_sd]], col = l+1, pch = 16)
# and precision model
new_preds <- predict(all_mods[[final_mod]][[l]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = l+1, lty = 2)
}
}
# return(LoD_vals)
}
plot(lot_1[[col_avg]], lot_1[[col_sd]],
xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 30)
new_preds <- predict(all_mods[[final_mod]][[1]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
# plot remaining profiles (if any)
if(n_lots > 1){
# loop through remaining reagent lots
for(l in 2:n_lots){
lot_l <- df[df[[col_lot]] == l,]
points(lot_l[[col_avg]], lot_l[[col_sd]], col = l+1, pch = 16)
# and precision model
new_preds <- predict(all_mods[[final_mod]][[l]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = l+1, lty = 2)
}
}
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 20)
new_preds <- predict(all_mods[[final_mod]][[1]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
plot(lot_1[[col_avg]], lot_1[[col_sd]],
xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 20)
new_preds <- predict(all_mods[[final_mod]][[1]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
# plot remaining profiles (if any)
if(n_lots > 1){
# loop through remaining reagent lots
for(l in 2:n_lots){
lot_l <- df[df[[col_lot]] == l,]
points(lot_l[[col_avg]], lot_l[[col_sd]], col = l+1, pch = 16)
# and precision model
new_preds <- predict(all_mods[[final_mod]][[l]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = l+1, lty = 2)
}
}
# linear
lin_mod <- lapply(lots_list, function(x) lm(sd_wl ~ avg, data = x))
# quadratic
quad_mod <- lapply(lots_list, function(x) lm(sd_wl ~ avg + I(avg^2), data = x))
# Sadler
# sadler_mod <- lapply(lots_list, function(x)
#   nls(sd_wl ~ I((a + b*avg)), start = list(a = 0, b = 1), data = sample_df))
sadler_mod <- lin_mod
all_mods <- list(lin_mod, quad_mod, sadler_mod) |> setNames(mod_names)
# find model with lowest AIC for each reagent lot
min_AIC <- vector()
for(l in 1:n_lots){
min_AIC[l] <- c(lapply(lin_mod, AIC)[[l]],
lapply(quad_mod, AIC)[[l]],
lapply(sadler_mod, AIC)[[l]]) |> which.min()
}
# which model is necessary? (most complex of all reagent lots)
mod_nb <- max(min_AIC)
best_mod <- mod_names[mod_nb]
# if user has selected a model
if(model != "lowest AIC"){
final_mod <- model
# warning if this model does not have the lowest AIC
if(best_mod != final_mod){
message(paste0("Warning: ", best_mod, " has a lower AIC than the selected model."))
}
# if user wants model with lowest AIC
}else{
final_mod <- best_mod
}
# set x and y limits for plot
x_lims <- c(min(sample_df[[col_avg]] - 0.1), max(sample_df[[col_avg]]) + 0.1)
y_lims <- c(min(sample_df[[col_sd]] - 0.1), max(sample_df[[col_sd]]) + 0.1)
# plot profile for first reagent lot
lot_1 <- df[df[[col_lot]] == 1,]
plot(lot_1[[col_avg]], lot_1[[col_sd]],
xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 20)
new_preds <- predict(all_mods[[final_mod]][[1]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
# plot remaining profiles (if any)
if(n_lots > 1){
# loop through remaining reagent lots
for(l in 2:n_lots){
lot_l <- df[df[[col_lot]] == l,]
points(lot_l[[col_avg]], lot_l[[col_sd]], col = l+1, pch = 16)
# and precision model
new_preds <- predict(all_mods[[final_mod]][[l]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = l+1, lty = 2)
}
}
library(detection)
LoD_precision_profile(sample_df, "reagent_lot", "sample", "avg", "sd_wl", 7.5)
LoD_precision_profile(sample_df, "reagent_lot", "sample", "avg", "sd_wl", 7.5)
LoD_precision_profile(sample_df, "reagent_lot", "sample", "avg", "sd_wl", 7.5, model = "quadratic")
LoD_precision_profile(sample_df, "reagent_lot", "sample", "avg", "sd_wl", 7.5, model = "linear")
library(detection)
LoD_precision_profile(sample_df, "reagent_lot", "sample", "avg", "sd_wl", 7.5, model = "linear")
View(df)
View(blank_df)
LoB <- 7.5
LoB + cp*(c(1, .51) %*% summary(pp_model1)$coef[,1])
cp <- qnorm(pct) / (1 - (1/(4*(N_tot-K)) ))
l = 1
# look at each lot separately
lot_l <- df[df[[col_lot]] == l,]
# critical value
N_tot <- nrow(lot_l)
K <- unique(lot_l[[col_sample]]) |> length() # number of samples
col_sample <- "sample"
K <- unique(lot_l[[col_sample]]) |> length() # number of samples
cp <- qnorm(pct) / (1 - (1/(4*(N_tot-K)) ))
LoB + cp*(c(1, .51)
)
qnorm(pct)
N_tot
K
N = 80
# critical value
N_tot <- N
K <- unique(lot_l[[col_sample]]) |> length() # number of samples
# critical value
N_tot <- N # total number of measurements per reagent lot
K <- unique(lot_l[[col_sample]]) |> length() # number of samples
cp <- qnorm(pct) / (1 - (1/(4*(N_tot-K)) ))
N_tot-K
1/(4*(N_tot-K))
(1 - (1/(4*(N_tot-K)) ))
cp <- qnorm(pct) / (1 - (1/(4*(N_tot-K)) ))
plot(lot_1[[col_avg]], lot_1[[col_sd]],
main = "Check that precision models fit points well!", xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 20)
new_preds <- predict(all_mods[[final_mod]][[1]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
# plot remaining profiles (if any)
if(n_lots > 1){
# loop through remaining reagent lots
for(l in 2:n_lots){
lot_l <- df[df[[col_lot]] == l,]
points(lot_l[[col_avg]], lot_l[[col_sd]], col = l+1, pch = 16)
# and precision model
new_preds <- predict(all_mods[[final_mod]][[l]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = l+1, lty = 2)
}
}
plot(lot_1[[col_avg]], lot_1[[col_sd]],
main = "Check model fit!", xlab = "Measurand", ylab = "Within-lab Precision", col = 2,
xlim = x_lims, ylim = y_lims, pch = 16)
# and precision model
new_vals <- seq(from = x_lims[1], to = x_lims[2], length = 20)
new_preds <- predict(all_mods[[final_mod]][[1]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = 2, lty = 2)
# plot remaining profiles (if any)
if(n_lots > 1){
# loop through remaining reagent lots
for(l in 2:n_lots){
lot_l <- df[df[[col_lot]] == l,]
points(lot_l[[col_avg]], lot_l[[col_sd]], col = l+1, pch = 16)
# and precision model
new_preds <- predict(all_mods[[final_mod]][[l]], new_vals |> as.data.frame() |> setNames("avg"))
lines(new_vals, new_preds, col = l+1, lty = 2)
}
}
LoB_dat <- as.data.frame(LoB) |> setNames("avg")
View(LoB_dat)
LoB_df <- as.data.frame(LoB) |> setNames("avg")
rm(LoB_dat)
LoD <- LoB + cp*predict(all_mods[[final_mod]][[l]], LoB |> as.data.frame() |> setNames("avg"))
LoB <- 0.51
LoD <- LoB + cp*predict(all_mods[[final_mod]][[l]], LoB |> as.data.frame() |> setNames("avg"))
N_tot <- 80*6
K <- unique(lot_l[[col_sample]]) |> length() # number of samples
cp <- qnorm(pct) / (1 - (1/(4*(N_tot-K)) ))
LoD <- LoB + cp*predict(all_mods[[final_mod]][[l]], LoB |> as.data.frame() |> setNames("avg"))
for(l in 1:n_lots){
# look at each lot separately
lot_l <- df[df[[col_lot]] == l,]
# critical value
N_tot <- N # total number of measurements per reagent lot
K <- unique(lot_l[[col_sample]]) |> length() # number of samples
cp <- qnorm(pct) / (1 - (1/(4*(N_tot-K)) ))
LoD_vals[l] <- LoB + cp*predict(all_mods[[final_mod]][[l]], LoB |> as.data.frame() |> setNames("avg"))
}
# # loop through each reagent lot
LoD_vals <- list()
for(l in 1:n_lots){
# look at each lot separately
lot_l <- df[df[[col_lot]] == l,]
# critical value
N_tot <- N # total number of measurements per reagent lot
K <- unique(lot_l[[col_sample]]) |> length() # number of samples
cp <- qnorm(pct) / (1 - (1/(4*(N_tot-K)) ))
LoD_vals[l] <- LoB + cp*predict(all_mods[[final_mod]][[l]], LoB |> as.data.frame() |> setNames("avg"))
}
View(LoD_vals)
View(LoD_vals)
all_mods[[final_mod]]
0.51 + 1.646[0.2801 + 0.0817*(0.51) + 0.0017*(0.51)^2]
0.51 + 1.646*(0.2801 + 0.0817*(0.51) + 0.0017*(0.51)^2)
