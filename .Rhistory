3.1, 4.1, 1.0, 3.4,
.1, .4, 2.9, -1.6,
4.0, 11.5, 4.5, 3.6,
4.4, 6.8, 7.1, 4.2,
3.7, 3.7, 5.3, 4.5,
4.0, 6.2, -.2, 2.3,
1.6, 2.6, 6.4, 5.7,
4.2, 3.7, 1.4, 1.5))
lowlvl_df <- data.frame(lot = c(rep(1, 12*5), rep(2, 12*5)),
day = rep(rep(c(1, 2, 3), each = 4, times = 10)),
sample = rep(c(1, 2, 3, 4, 5), each = 12, times = 2),
rep = rep(c(1, 2, 3, 4), times = 3*5*2),
val = c(21.0, 22.8, 28.2, 25.9,
26.4, 28.3, 20.7, 21.9,
24.7, 22.5, 28.5, 29.2,
13.3, 12.6, 18.2, 14.7,
17.8, 14.0, 14.1, 12.5,
11.3, 12.2, 16.2, 13.9,
12.8, 12.9, 17.4, 16.0,
15.9, 14.1, 11.3, 9.4,
10.6, 13.6, 17.6, 14.9,
17.3, 19.2, 21.5, 22.2,
24.1, 25.8, 16.0, 16.4,
24.9, 23.8, 22.1, 26.1,
19.2, 22.7, 28.3, 26.2,
25.1, 30.3, 23.4, 19.2,
26.3, 23.1, 27.5, 30.1,
22.0, 22.5, 21.8, 22.1,
20.3, 21.0, 25.3, 26.0,
27.2, 25.1, 25.3, 25.3,
15.6, 21.2, 14.8, 14.9,
16.0, 15.8, 21.6, 22.8,
15.3, 18.7, 18.3, 19.5,
13.0, 15.9, 9.0, 7.0,
13.4, 8.5, 16.3, 18.1,
12.4, 11.1, 11.3, 10.1,
18.8, 17.6, 14.1, 14.9,
19.2, 15.8, 19.8, 21.4,
18.0, 18.0, 19.6, 23.1,
32.9, 30.4, 29.4, 27.6,
27.7, 30.6, 31.4, 30.4,
32.5, 28.9, 29.8, 35.1))
sample_df <- data.frame(lot = c(rep("1", 6), rep("2", 6)),
sample = rep(LETTERS[1:6], 2),
avg = c(.69, 1.42, 2.65, 4.08, 6.08, 10.36,
.78, 1.73, 2.89, 3.82, 6.33, 10.92),
sd_wl = c(.39, .39, .46, .55, .64, 1.12,
.29, .54, .55, .63, .82, 1.38))
probit_df <- data.frame(conc = rep(c(0, .006, .014, .025, .05, .15, .3, .5), each = 3),
lot = rep(c(1, 2, 3), times = 8),
obs_pos = c(0, 0, 0,
11, 12, 22,
15, 22, 31,
23, 28, 27,
29, 32, 32,
32, 32, 32,
32, 32, 32,
32, 32, 32),
tot = c(22, 22, 22,
30, 30, 34,
30, 30, 34,
rep(32, 15)))
loq_df <- data.frame(lot = rep(c(1, 2), each = 9),
sample = rep(1:9, times = 2),
avg = c(.04, .053, .08, .111, .137, .164, .190, .214, .245,
.041, .047, .077, .106, .136, .159, .182, .205, .234),
sd_wl = c(.016, .016, .016, .017, .014, .012, .011, .016, .013,
.018, .014, .012, .019, .016, .015, .015, .016, .014))
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
probit_df <- probit_df |> subset(!conc %in% c(0.006, 0.014))
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
a <- LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
View(a)
LoQ_functional(loq_df, "lot", "sample", "avg", "sd_wl", target_cv = 10, coeff_start = c(0.5, -1))
probit_df <- data.frame(conc = rep(c(0, .006, .014, .025, .05, .15, .3, .5), each = 3),
lot = rep(c(1, 2, 3), times = 8),
obs_pos = c(0, 0, 0,
11, 12, 22,
15, 22, 31,
23, 28, 27,
29, 32, 32,
32, 32, 32,
32, 32, 32,
32, 32, 32),
tot = c(22, 22, 22,
30, 30, 34,
30, 30, 34,
rep(32, 15)))
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
probit_df <- probit_df |> subset(!conc %in% c(0.006, 0.014))
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
# plot observed data
with(lot_l,
plot(conc, hit_rate, type = "p", log = "x", pch = 16,
main = paste0("Reagent Lot ", l),
xlab = "Concentration (log scale)",
ylab = "Hit Rate",
ylim = c(0,1),
axes = FALSE))
# loop through reagent lots
for(l in 1:n_lots){
# look at each lot separately
lot_l <- df[df$lot == l,]
pred_l <- pred_df[pred_df$lot == l,]
# plot observed data
with(lot_l,
plot(conc, hit_rate, type = "p", log = "x", pch = 16,
main = paste0("Reagent Lot ", l),
xlab = "Concentration (log scale)",
ylab = "Hit Rate",
ylim = c(0,1),
axes = FALSE))
# function to hide unnecessary GLM warning
hide_warning <- function(w){
if((any(grepl("fitted probabilities numerically 0 or 1 occurred", w)))){
invokeRestart("muffleWarning")}
}
# use tryCatch to identify if the GLM doesn't converge
# if it doesn't converge, don't plot model fit
tryCatch(
expr = {
# test to see if the selected model converges
# hide warning about some probabilities being 0 or 1
if(log10_trans){
test_mod <- withCallingHandlers(glm(cbind(obs_pos, tot - obs_pos) ~ conc_log10,
data = lot_l,
family = binomial(link = "probit")),
warning = hide_warning)
}else{
test_mod <- withCallingHandlers(glm(cbind(obs_pos, tot - obs_pos) ~ conc,
data = lot_l,
family = binomial(link = "probit")),
warning = hide_warning)
}
# shading
polygon(c(pred_l$conc, rev(pred_l$conc)), c(pred_l$upr, rev(pred_l$lwr)),
col = "grey70", border = "black")
# # upper bound
# lines(pred_l$conc,
#       pred_l$upr,
#       type="l", col="grey30")
# # lower bound
# lines(pred_l$conc,
#       pred_l$lwr,
#       type="l", col="grey30")
# model fitted values
lines(pred_l$conc,
pred_l$p_hat,
type="l", col="black")
# line at 1-beta (typically 0.95) % hit rate
abline(h = pct, col = 'red', lty = 2)
# add points again so they're on top
points(lot_l$conc, lot_l$hit_rate, pch = 16)
},
warning = function(w){
warning("Original error message: ", w,
"The GLM algorithm did not converge for lot ", l,
", likely because most hit rates
are very close to 0 or 1. More measurements are needed in the range of
concentration values for which the hit rate is between 0 and 1.")
# text("GLM didn't\n converge", cex = 0.7,  col = "red",
#      x = quantile(pred_df$conc, 0.1), y = 0.1)
}
)
# find first predicted probability greater than pct (typically 95%) and set as LoD
LoD_vals[l] <- pred_l[pred_l$p_hat >= pct,]$conc[1]
names(LoD_vals)[l] <- paste0("lot_", l)
}
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
par()
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
par()
par(mfrow = c(1, n_lots),
mar = c(3, 3, 2, 1),
mgp = c(2, 0.5, 0),
tck = -.01)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
dev.off()
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
#---- plot -----#
plot.new()
par()
par(mfrow = c(1, n_lots),
mar = c(3, 3, 2, 1),
mgp = c(2, 0.5, 0),
tck = -.01)
n_lots = 3
par(mfrow = c(1, n_lots),
mar = c(3, 3, 2, 1),
mgp = c(2, 0.5, 0),
tck = -.01)
m <- matrix(c(1:n_lots, rep(n_lots+1, n_lots)), nrow = 2, ncol = n_lots, byrow = TRUE)
layout(mat = m, heights = c(0.1, 0.9))
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
dev.off()
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
library(detection)
dev.off()
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
dev.off()
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
dev.off()
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
#---- plot -----#
plot.new()
par()
par(mfrow = c(1, n_lots),
mar = c(3, 3, 2, 1),
mgp = c(2, 0.5, 0),
tck = -.01)
#---- plot -----#
plot.new()
par(mfrow = c(1, n_lots),
mar = c(3, 3, 2, 1),
mgp = c(2, 0.5, 0),
tck = -.01)
m <- matrix(c(1:n_lots, rep(n_lots+1, n_lots)), nrow = 2, ncol = n_lots, byrow = TRUE)
layout(mat = m, heights = c(0.1, 0.9))
LoD_vals <- list()
# loop through reagent lots
for(l in 1:n_lots){
# look at each lot separately
lot_l <- df[df$lot == l,]
pred_l <- pred_df[pred_df$lot == l,]
# plot observed data
with(lot_l,
plot(conc, hit_rate, type = "p", log = "x", pch = 16,
main = paste0("Reagent Lot ", l),
xlab = "Concentration (log scale)",
ylab = "Hit Rate",
ylim = c(0,1),
axes = FALSE))
# function to hide unnecessary GLM warning
hide_warning <- function(w){
if((any(grepl("fitted probabilities numerically 0 or 1 occurred", w)))){
invokeRestart("muffleWarning")}
}
# use tryCatch to identify if the GLM doesn't converge
# if it doesn't converge, don't plot model fit
tryCatch(
expr = {
# test to see if the selected model converges
# hide warning about some probabilities being 0 or 1
if(log10_trans){
test_mod <- withCallingHandlers(glm(cbind(obs_pos, tot - obs_pos) ~ conc_log10,
data = lot_l,
family = binomial(link = "probit")),
warning = hide_warning)
}else{
test_mod <- withCallingHandlers(glm(cbind(obs_pos, tot - obs_pos) ~ conc,
data = lot_l,
family = binomial(link = "probit")),
warning = hide_warning)
}
# shading
polygon(c(pred_l$conc, rev(pred_l$conc)), c(pred_l$upr, rev(pred_l$lwr)),
col = "grey70", border = "black")
# # upper bound
# lines(pred_l$conc,
#       pred_l$upr,
#       type="l", col="grey30")
# # lower bound
# lines(pred_l$conc,
#       pred_l$lwr,
#       type="l", col="grey30")
# model fitted values
lines(pred_l$conc,
pred_l$p_hat,
type="l", col="black")
# line at 1-beta (typically 0.95) % hit rate
abline(h = pct, col = 'red', lty = 2)
# add points again so they're on top
points(lot_l$conc, lot_l$hit_rate, pch = 16)
axis(side = 1)
axis(side = 2)
},
warning = function(w){
warning("Original error message: ", w,
"The GLM algorithm did not converge for lot ", l,
", likely because most hit rates
are very close to 0 or 1. More measurements are needed in the range of
concentration values for which the hit rate is between 0 and 1.")
# text("GLM didn't\n converge", cex = 0.7,  col = "red",
#      x = quantile(pred_df$conc, 0.1), y = 0.1)
}
)
# find first predicted probability greater than pct (typically 95%) and set as LoD
LoD_vals[l] <- pred_l[pred_l$p_hat >= pct,]$conc[1]
names(LoD_vals)[l] <- paste0("lot_", l)
}
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
par("mar")
par(mar=c(1,1,1,1))
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
par(mar=c(1,1,1,1))
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
#---- plot -----#
plot.new()
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
dev.off()
library(detection)
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
LoD_probit <- function(df, col_lot, col_conc, col_obs_pos, col_tot, LoB,
log10_trans = FALSE, beta = 0.05, always_sep_lots = FALSE){
# check for missing data
if(!all(complete.cases(df))){
# remove rows with missing values (and give warning)
df <- df[complete.cases(df),]
warning("Ignoring rows with missing values.")
}
# if column for reagent lot is NULL, make a column with a vector of 1s (all lot 1)
if(is.null(col_lot)){
df$lot <- 1
}
# confirm that column names exist in df
stopifnot("`col_lot` is not a column in df" = col_lot %in% names(df))
stopifnot("`col_conc` is not a column in df" = col_conc %in% names(df))
stopifnot("`col_obs_pos` is not a column in df" = col_obs_pos %in% names(df))
stopifnot("`col_tot` is not a column in df" = col_tot %in% names(df))
# rename columns in df
names(df)[names(df) == col_lot] <- "lot"
names(df)[names(df) == col_conc] <- "conc"
names(df)[names(df) == col_obs_pos] <- "obs_pos"
names(df)[names(df) == col_tot] <- "tot"
# confirm that all columns are numeric and positive
stopifnot("`col_lot` must be numeric" = (is.numeric(df$lot) & all(df$lot >= 0)))
stopifnot("`col_conc` must be numeric" = is.numeric(df$conc)) & all(df$conc >= 0)
stopifnot("`col_obs_pos` must be numeric" = is.numeric(df$obs_pos)) & all(df$obs_pos >= 0)
stopifnot("`col_tot` must be numeric" = (is.numeric(df$tot) & all(df$tot >= 0)))
# percentile
pct <- 1 - beta
# find number of reagent lots
n_lots <- unique(df$lot) |> length()
# if there are more than 3 lots and always_sep_lots = FALSE, reset all reagent lot values to 1
if((n_lots > 3 & !always_sep_lots)){
df$lot <- 1
n_lots <- 1
}
# find hit rate
df$hit_rate <- df$obs_pos / df$tot
# remove rows with concentration of 0
df <- df[df$conc != 0,]
# log transform concentration vals
df$conc_log10 <- df$conc |> log10()
LoD_vals <- list()
mod <- list()
mod_coeff <- list()
AIC_glm <- vector()
AIC_glm_log10 <- vector()
chisq_p_val <- vector()
plot.new()
par(mfrow = c(1, n_lots),
mar = c(3, 3, 2, 1),
mgp = c(2, 0.5, 0),
tck = -.01)
# loop through each reagent lot
for(l in 1:n_lots){
# look at each lot separately
lot_l <- df[df$lot == l,]
# function to hide unnecessary GLM warning
hide_warning <- function(w){
if((any(grepl("fitted probabilities numerically 0 or 1 occurred", w)))){
invokeRestart("muffleWarning")}
}
# fit GLMs with 1) concentrations and 2) log10 concentrations
tryCatch(
expr = {
mod_glm <- withCallingHandlers(glm(cbind(obs_pos, tot - obs_pos) ~ conc,
data = lot_l,
family = binomial(link = "probit")),
warning = hide_warning)
mod_glm_log10 <- withCallingHandlers(glm(cbind(obs_pos, tot - obs_pos) ~ conc_log10,
data = lot_l,
family = binomial(link = "probit")),
warning = hide_warning)
},
warning = function(w){
stop("Original error message: ", w,
"The GLM algorithm did not converge for lot ", l,
", likely because most hit rates
are very close to 0 or 1. More measurements are needed in the range of
concentration values for which the hit rate is between 0 and 1.")
}
)
# get model AIC
AIC_glm[l] <- AIC(mod_glm)
AIC_glm_log10[l] <- AIC(mod_glm_log10)
# select model based on user input
if(log10_trans){
mod[[l]] <- mod_glm_log10
}else{
mod[[l]] <- mod_glm
}
# get model coefficients
mod_coeff[[l]] <- summary(mod[[l]])$coef[,1]
names(mod_coeff)[l] <- paste0("lot_", l)
# check model fit with deviance
chisq_stat <- sum(residuals(mod[[l]], type = "pearson")^2)
chisq_p_val[l] <- 1 - pchisq(chisq_stat, df = mod[[l]]$df.residual)
# use probit inverse to get predicted probabilities and CIs for a range of concentrations
inverse_link <- family(mod[[l]])$linkinv
# if log transformed
if(log10_trans){
new_vals <- seq(log(0.0001), log(1), by = 0.001) # possible log conc. values
pred_df <- predict(mod[[l]],
newdata = data.frame("conc_log10" = new_vals),
se.fit = TRUE)[1:2] |> as.data.frame()
pred_df$conc <- 10^(new_vals)
# if not log transformed
}else{
new_vals <- seq(0, 1, by = 0.0001) # possible conc. values
pred_df <- predict(mod[[l]],
newdata = data.frame("conc" = new_vals),
se.fit = TRUE)[1:2] |> as.data.frame()
pred_df$conc <- new_vals
}
# use inverse link to get predicted probabilities and 95% CI
pred_df$p_hat <- inverse_link(pred_df$fit)
pred_df$lwr <- inverse_link(pred_df$fit - 1.96*pred_df$se.fit)
pred_df$upr <- inverse_link(pred_df$fit + 1.96*pred_df$se.fit)
# plot curves
with(lot_l,
plot(conc, hit_rate, type = "p", log = "x", pch = 16,
main = paste0("Reagent Lot ", l),
xlab = "Concentration (log scale)",
ylab = "Hit Rate",
ylim = c(0,1)))
lines(pred_df$conc,
pred_df$upr,
type="l", col="grey60")
lines(pred_df$conc,
pred_df$lwr,
type="l", col="grey60")
lines(pred_df$conc,
pred_df$p_hat,
type="l", col="black")
abline(h = pct, col = 'red', lty = 2)
# find first predicted probability greater than pct (usually 95%) and set as LoD
LoD_vals[l] <- pred_df[pred_df$p_hat >= pct,]$conc[1]
names(LoD_vals)[l] <- paste0("LoD_lot_", l)
}
hit_rate_plot <- recordPlot()
par(mfrow = c(1,1))
# compare model AIC (log transformed vs. not log transformed) for all lots
# if any reagent lots have better model fit with log transform, use log transform
log10_better <- any((AIC_glm - AIC_glm_log10) > 0)
# message for user
if(!log10_trans & log10_better){
warning("The probit models have a better fit on at least one reagent lot if a log transformation
of the concentration values is performed. Consider setting `log10_trans` = TRUE.")
}
# warning about always_sep_lots when n_lots > 3
if(always_sep_lots & length(LoD_vals) > 3){
warning("Since there are at least four reagent lots in the data provided, CLSI guidelines
recommend combining all reagent lots. Set `always_sep_lots` = FALSE to obtain a single,
reportable estimate of LoD.")
# if only one LoD value, report as LoB_reported (not LoD_lot_1)
}else if(length(LoD_vals) == 1){
names(LoD_vals)[1] <- "LoD_reported"
# otherwise find max LoD to report
}else{
LoD_vals[n_lots + 1] <- unlist(LoD_vals) |> max()
names(LoD_vals)[n_lots + 1] <- "LoD_reported"
}
# warning about GOF
if(any(chisq_p_val < 0.05)){
warning("Pearson chi-square goodness-of-fit tests indicate that the probit model fit
may be insufficient for at least one reagent lot (p-values: ",
paste(round(chisq_p_val,3), collapse = ", "), ").")
}
output <- list(LoD_vals, mod_coeff, hit_rate_plot)
names(output) <- c("LoD_values", "mod_coeff", "hit_rate_plot")
return(output)
}
LoD_probit(probit_df, "lot", "conc", "obs_pos", "tot", 0, log10_trans = TRUE)
