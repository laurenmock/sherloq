K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val[l] <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val[l]))
}
}
LoB(blank_df, NULL, "sample", "pg.ml", parametric = TRUE, always_sep_lots = TRUE)
LoB(blank_df, "hi", "sample", "pg.ml", parametric = TRUE, always_sep_lots = TRUE)
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
# percentile
pct <- 1 - alpha
# confirm that all col_sample and col_value exist
stopifnot("`col_lot` does not exist" = col_lot %in% names(df) | is.null(col_lot))
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# if col_lot exists, find # of unique values (number of reagent lots), otherwise set to 1
if(is.null(col_lot)){
df$lot <- 1
n_lots <- 1
}else{
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}
# combine lots if >3 and user has not specified always_sep_lots
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided, CLSI guidelines recommend combining all reagent lots. Consider setting `always_sep_lots` = FALSE.")
}
# loop through each reagent lot (if n_lots = 1, then we will only go through the loop once)
LoB_val <- vector()
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val[l] <- sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(stats::shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val[l] <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val[l]))
}
}
LoB(blank_df, "hi", "sample", "pg.ml", parametric = TRUE, always_sep_lots = TRUE)
LoB(blank_df, NULL, "sample", "pg.ml", parametric = TRUE, always_sep_lots = TRUE)
LoB(blank_df, "reagent_lot", "sample", "pg.ml", parametric = TRUE, always_sep_lots = TRUE)
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
# percentile
pct <- 1 - alpha
# confirm that all col_sample and col_value exist
stopifnot("`col_lot` does not exist" = col_lot %in% names(df) | is.null(col_lot))
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# if col_lot exists, find # of unique values (number of reagent lots), otherwise set to 1
if(is.null(col_lot)){
df$lot <- 1
n_lots <- 1
}else{
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}
# combine lots if >3 and user has not specified always_sep_lots
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided, CLSI guidelines recommend combining all reagent lots. Consider setting `always_sep_lots` = FALSE.")
}
# loop through each reagent lot (if n_lots = 1, then we will only go through the loop once)
LoB_val <- vector()
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val[l] <- sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(stats::shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val[l] <- mean_B + cp*sd_B
}
print(paste0("LoB for lot ", l, ": ", LoB_val[l]))
}
}
LoB(blank_df, "reagent_lot", "sample", "pg.ml", parametric = TRUE, always_sep_lots = TRUE)
LoB(blank_df, "reagent_lot", "sample", "pg.ml", parametric = TRUE)
LoB(blank_df, "reagent_lot", "sample", "pg.ml")
# This took like 20 minutes to type out
blank_df <- data.frame(reagent_lot = c(rep(1, 12*5), rep(2, 12*5)),
day = rep(rep(c(1, 2, 3), each = 4, times = 10)),
sample = rep(c(1, 2, 3, 4, 5), each = 12, times = 2),
replicate = rep(c(1, 2, 3, 4), times = 3*5*2),
`pg/ml` = c(2.6, -.8, 5.5, 6.0,
4.5, .6, -2.3, 3.4,
5.9, 7.6, 4.1, -1.4,
1.0, 2.9, 4.9, 8.0,
6.9, 5.0, 3.4, 1.2,
6.5, 5.6, -2.2, 2.3,
-4.4, -3.4, 7.0, 6.9,
4.3, 3.2, -1.4, 4.2,
5.9, 7.6, 3.8, 5.8,
1.5, -1.9, 5.1, 5.7,
4.1, 4.5, -.6, .5,
5.4, 7.6, 4.4, 6.6,
1.2, -.7, 6.1, 5.1,
4.8, 3.3, -2.8, -1.4,
8.7, 3.6, 5.1, 3.5,
4.6, 4.1, 1.6, 3.7,
2.2, .7, 4.6, 2.6,
1.1, -4.4, .9, .7,
9.2, 8.3, 4.8, 5.4,
4.8, 6.3, 5.4, 9.6,
7.7, 3.1, 6.1, 10.0,
6.1, 3.2, 3.9, 1.4,
3.1, 4.1, 1.0, 3.4,
.1, .4, 2.9, -1.6,
4.0, 11.5, 4.5, 3.6,
4.4, 6.8, 7.1, 4.2,
3.7, 3.7, 5.3, 4.5,
4.0, 6.2, -.2, 2.3,
1.6, 2.6, 6.4, 5.7,
4.2, 3.7, 1.4, 1.5))
detach("package:detection", unload=TRUE)
install()
check()
library(detection)
LoB(blank_df, "reagent_lot", "sample", "pg.ml")
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
# percentile
pct <- 1 - alpha
# confirm that all col_sample and col_value exist
stopifnot("`col_lot` does not exist" = col_lot %in% names(df) | is.null(col_lot))
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# if col_lot is NULL, set # of lots equal to 1
if(is.null(col_lot)){
df$lot <- 1
n_lots <- 1
# otherwise find # of unique values (number of lots)
}else{
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}
# combine lots if >3 lots and user has not specified always_sep_lots = TRUE
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided, CLSI guidelines recommend combining all reagent lots. Consider setting `always_sep_lots` = FALSE.")
}
# loop through each reagent lot
LoB_val <- vector()
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val[l] <- sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(stats::shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val[l] <- mean_B + cp*sd_B
}
# print LoB for each reagent lot (if separate)
print(paste0("LoB for lot ", l, ": ", LoB_val[l]))
}
}
LoB(blank_df, "reagent_lot", "sample", "pg.ml")
LoB(blank_df, "reagent_lot", "sample", "pg.ml", parametric = TRUE)
LoB(blank_df, "reagent_lot", "sample", "pg.ml", parametric = 5)
?match.arg
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
parametric <- match.arg(parametric)
# confirm that all col_sample and col_value exist
stopifnot("`col_lot` does not exist" = col_lot %in% names(df) | is.null(col_lot))
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# percentile
pct <- 1 - alpha
# if col_lot is NULL, set # of lots equal to 1
if(is.null(col_lot)){
df$lot <- 1
n_lots <- 1
# otherwise find # of unique values (number of lots)
}else{
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}
# combine lots if >3 lots and user has not specified always_sep_lots = TRUE
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided, CLSI guidelines recommend combining all reagent lots. Consider setting `always_sep_lots` = FALSE.")
}
# loop through each reagent lot
LoB_val <- vector()
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val[l] <- sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(stats::shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val[l] <- mean_B + cp*sd_B
}
# print LoB for each reagent lot (if separate)
print(paste0("LoB for lot ", l, ": ", LoB_val[l]))
}
}
LoB(blank_df, "reagent_lot", "sample", "pg.ml", parametric = TRUE)
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
parametric <- match.arg(as.character(parametric))
# confirm that all col_sample and col_value exist
stopifnot("`col_lot` does not exist" = col_lot %in% names(df) | is.null(col_lot))
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# percentile
pct <- 1 - alpha
# if col_lot is NULL, set # of lots equal to 1
if(is.null(col_lot)){
df$lot <- 1
n_lots <- 1
# otherwise find # of unique values (number of lots)
}else{
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}
# combine lots if >3 lots and user has not specified always_sep_lots = TRUE
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided, CLSI guidelines recommend combining all reagent lots. Consider setting `always_sep_lots` = FALSE.")
}
# loop through each reagent lot
LoB_val <- vector()
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val[l] <- sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(stats::shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val[l] <- mean_B + cp*sd_B
}
# print LoB for each reagent lot (if separate)
print(paste0("LoB for lot ", l, ": ", LoB_val[l]))
}
}
LoB(blank_df, "reagent_lot", "sample", "pg.ml", parametric = TRUE)
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = c(FALSE, TRUE), always_sep_lots = FALSE){
parametric <- match.arg(as.character(parametric))
# confirm that all col_sample and col_value exist
stopifnot("`col_lot` does not exist" = col_lot %in% names(df) | is.null(col_lot))
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# percentile
pct <- 1 - alpha
# if col_lot is NULL, set # of lots equal to 1
if(is.null(col_lot)){
df$lot <- 1
n_lots <- 1
# otherwise find # of unique values (number of lots)
}else{
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}
# combine lots if >3 lots and user has not specified always_sep_lots = TRUE
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided, CLSI guidelines recommend combining all reagent lots. Consider setting `always_sep_lots` = FALSE.")
}
# loop through each reagent lot
LoB_val <- vector()
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val[l] <- sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(stats::shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val[l] <- mean_B + cp*sd_B
}
# print LoB for each reagent lot (if separate)
print(paste0("LoB for lot ", l, ": ", LoB_val[l]))
}
}
LoB(blank_df, "reagent_lot", "sample", "pg.ml", parametric = TRUE)
LoB <- function(df, col_lot, col_sample, col_value,
alpha=0.05, parametric = FALSE, always_sep_lots = FALSE){
# figure out how to use match.arg to allow only TRUE and FALSE for parametric and always_sep_lots
# confirm that all col_sample and col_value exist
stopifnot("`col_lot` does not exist" = col_lot %in% names(df) | is.null(col_lot))
stopifnot("`col_sample` does not exist" = col_sample %in% names(df))
stopifnot("`col_value` does not exist" = col_value %in% names(df))
# confirm that col_value is numeric
stopifnot("`col_value` must be numeric" = is.numeric(df[[col_value]]))
# percentile
pct <- 1 - alpha
# if col_lot is NULL, set # of lots equal to 1
if(is.null(col_lot)){
df$lot <- 1
n_lots <- 1
# otherwise find # of unique values (number of lots)
}else{
df$lot <- df[[col_lot]]
n_lots <- unique(df$lot) |> length()
}
# combine lots if >3 lots and user has not specified always_sep_lots = TRUE
if(!always_sep_lots & (n_lots > 3)){
df$lot <- 1
n_lots <- 1
}
if(always_sep_lots & n_lots >3){
message("Warning: Since there are at least four reagent lots in the data provided, CLSI guidelines recommend combining all reagent lots. Consider setting `always_sep_lots` = FALSE.")
}
# loop through each reagent lot
LoB_val <- vector()
for(l in 1:n_lots){
# look at each lot separately
lot_l <- subset(df, lot == l)
# number of reagents
B <- nrow(lot_l)
# non-parametric
if(!parametric){
# exact rank position and nearest integers
rank_exact <- .5 + B*pct
rank_below <- floor(rank_exact)
rank_above <- ceiling(rank_exact)
# sort measurements
sorted <- sort(lot_l[[col_value]])
# interpolate measurement for exact rank position (LoB)
LoB_val[l] <- sorted[rank_below] + (rank_exact - rank_below)*(sorted[rank_above] - sorted[rank_below])
}
# parametric
if(parametric){
# test to see if normally distributed
if(stats::shapiro.test(lot_l[[col_value]])$p.value <= 0.05){
message("Warning: These values do not appear to be normally distributed. Consider a log transformation or the non-parametric approach.")
}
# mean and SD
mean_B <- mean(lot_l[[col_value]])
sd_B <- stats::sd(lot_l[[col_value]])
# critical value
K <- unique(lot_l[[col_sample]]) |> length()
cp <- stats::qnorm(pct) / (1 - (1/(4*(B-K)) ))
# calculate LoB
LoB_val[l] <- mean_B + cp*sd_B
}
# print LoB for each reagent lot (if separate)
print(paste0("LoB for lot ", l, ": ", LoB_val[l]))
}
}
LoB(blank_df, "reagent_lot", "sample", "pg.ml", parametric = TRUE)
